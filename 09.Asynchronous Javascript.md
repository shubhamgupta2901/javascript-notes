## Asynchronous Java
 * [Event Loop](#event-loop)
  
##

* Asynchrony in computer programming refers to the occurrence of events independently of the main program flow and ways to deal with such events.

* The idea behind asynchronous JavaScript is simple: we do not wait for a long running operation to finish its work and then do something with the result. Instead we let that function do its job in the background and we move on with the code execution. This way the code is never blocked. And we use callback function to defer action into the future.

* In programming languages like Java or C# the “main program flow” happens on the main thread or process and “the occurrence of events independently of the main program flow” is the spawning of new threads or processes that runs code in parallel to the “main program flow”.

* This is not the case with JavaScript. That is because a JavaScript program is single threaded and all code is executed in a sequence, not in parallel. In JavaScript this is handled by using what is called an **“asynchronous non-blocking I/O model”**. What that means is that while the execution of JavaScript is blocking, I/O operations are not. 

* I/O operations can be fetching data over the internet with Ajax or over WebSocket connections, querying data from a database such as MongoDB or accessing the filesystem with the NodeJs “fs” module. All these kind of operations are done in parallel to the execution of your code and it is not JavaScript that does these operations; to put it simply, the underlying engine does it.
  
### Event Loop

* Event loop is part of the bigger picture of what happens behind the scenes of JavaScript when we call functions and handle events like DOM events. Execution Stack, Web APIs, Message Queue, Event Loop together make the JavaScript Runtime. This Runtime is responsible for how JavaScript works behind the scenes as it executes our code.
![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop1.png "")

* Consider the following script:

```javaScript
const first = () =>{
	console.log('First');
	second();
	console.log('End');
}

const second = ()=>{
	setTimeout(()=>{
		console.log("Second");
	},2000);
}
first();
```

* Lets understand how this code is executed inside our JavaScript Engine.
  * It starts by calling the ```first()``` function. An execution context for that function is put on the top of the execution stack.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop2.png "")

	* In the next line of code ```console.log()``` function is called and a new execution context is created for that function.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop3.png "")

	* text is logged on the console, and the function returns, and its execution context is popped off the stack.

	* Next ```second()``` is called, a new execution context is created and pushed on to the execution stack.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop4.png "")

	* ```setTimeout()``` is called inside ```second()``` and it's execution context is created and pushed to the execution stack.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop6.png "")

	* ```setTimeout()``` is part of Web APIs, which actually live outside the JavaScript Engine itself. Things like DOM Manipulation methods, HTTP requests for AJAX, local storage etc actually live outside the javaScript Engine. We just have access to them because they are also in the JavaScript Runtime. So this is the place where the timer will keep running for 2 seconds, asynchronously, so that our code can keep running without being blocked.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop7.png "")

	* When we call the ```setTimeout``` function, the timer is created together with the callback function, right inside the web api envoirnment. And there it will keep sitting untill it finishes it work. The callback function is not called right now, but instead it remains attached to the timer until it finishes.  
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop8.png "")
	
	* And since the timer keeps working in the *background*, we don't have to wait and we can keep executing our code.

	* Next thing ```setTimeout()``` returns, and its execution context is popped off the execution stack.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop9.png "")

	* ```second()``` returns and its execution context is popped off the execution stack.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop10.png "")

	* In the next line of code ```console.log()``` function is called  by ```first()``and a new execution context is created for that function. 
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop11.png "")

	* text is logged on the console, and the function returns, and its execution context is popped off the stack.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop12.png "")

	* The ```first()``` returns, its execution context gets popped off the stack and not the execution stack is completely empty.

	* Once the seconds have passed, the timer disappears and the callback function now moves to the **Message Queue**, where it waits to be executed, as soon as the execution stack is empty. This is exactly what happens with DOM events as well. In case of DOM events the event listeners sit in the web API envoirnment waiting for certain event to happen. And as soon as that event happens, the callback function is placed on the message queue, ready to be executed.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop13.png "")

	* The job of the Event loop is to constantly monitor the Message Queue and Execution Stack. It polls the Message Queue and pushes the first callback function in Message Queue to the Execution Stack, as soon as the stack is empty.

	* In our example, the Execution Stack is empty, and we have one callback function waiting to be executed. The Event Loop takes the callback and pushes it to the stack, where a new Execution Context is created for that function.
  
	![](https://github.com/shubhamgupta2901/javascript-notes/blob/master/assets/event%20loop14.png "")

	* Inside the callback function, we simply run the ```console.log()``` function, then the context pops off for ```console.log()``` function and then the context of callback function pops off. And we're done.

