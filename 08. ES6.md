## ES6
* [```let``` and ```const```](#let-and-const)
* [Blocks and IIFEs](#blocks-and-iifes)
* [Strings](#strings)
* [Arrow Functions](#arrow-functions)
* [Destructuring](#destructuring)
* [Arrays](#arrays)
* [Spread opreator](#spread-operator)
* [Rest and Default Parameters](#rest-and-default-parameters)
* [Maps](#maps)
* [Classes and Subclasses](#classes-and-subclasses)

### ```let``` and ```const```
* Instead of using ```var``` keyword, ES6 allows us to use ```let``` and ```const```.
* ```const``` is to be used for variables which will not change their values. There value can not be mutated.
* ```const``` variables need to be initiallized at the time of declaration. Otherwise we get ```Uncaught SyntaxError: Missing initializer in const declaration```

* ES5 Syntax:
```javascript
var nameES5 = 'Jane Smith';
var ageES5 = 23;
nameES5 = 'Jane Miller';
console.log(nameES5); //Jane Miller
```
* ES6 Syntax:
```javascript
const nameES6 = 'Jane Smith';
let ageES6 = 23;
ageES6 = 24;
console.log(ageES6); // 24
//nameES6 = 'Jane Miller'; // Uncaught TypeError: Assignment to constant variable.
```

* variables declared with ```var``` in ES5 are *function-scoped*, but variables declared with ```const``` and ```let``` in ES6 are *block-scoped*.
* A block groups zero or more statements.The block is delimited by a pair of curly brackets ```{}``` and may optionally be labelled.
* For example: 
ES5
```javascript
function driversLicense(passedTest){
	if(passedTest){
		var firstName = 'John';
		var yearOfBirth = 1990;

		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
	}
}
driversLicense(true);
```
OUTPUT: 
```John born in 1990 is now officially allowed to drive car.```

Also in ES5, 

```javascript
function driversLicense(passedTest){
	if(passedTest){
		var firstName = 'John';
		var yearOfBirth = 1990;
	}
	console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
}
driversLicense(true);
```
OUTPUT: 
```John born in 1990 is now officially allowed to drive car.```

* Lets look at same code in ES6 using ```const``` and ```let```:

```javascript
function driversLicense(passedTest){
	if(passedTest){
		let firstName = 'John';
		const yearOfBirth = 1990;
		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
	}
}
driversLicense(true);
```
OUTPUT: 
```John born in 1990 is now officially allowed to drive car.```


```javascript
function driversLicense(passedTest){
	if(passedTest){
		let firstName = 'John';
		const yearOfBirth = 1990;
	}
	console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
}
driversLicense(true);
```
OUTPUT: 
```Error: Uncaught ReferenceError: firstName is not defined```

* Another example for scoping is:
```javascript
let i = 23;
for (let i = 0; i< 5; i++){
	console.log(i);
}
console.log(i);
```
OUTPUT:
```
0
1
2
3
4
23
```

* This means assigning other values to ```i``` in the loop, doesn't change the value of ```i``` variable that we have defined before the for loop. Again this is because variables declared with ```let``` and ```const``` are block-scoped. And so the ```i``` variable inside the loop is a completeley different variable than the variable ```i``` that was defined before it.

* Where as in ES5: 

```javascript
var i = 23;
for (var i = 0; i< 5; i++){
	console.log(i);
}
console.log(i);
```
OUTPUT:
```
0
1
2
3
4
5
```

* Another difference between ES5 and ES6 is the way variables can be accessed before their declaration. 

* In ES5, when we use variables before they are declared, we get the value ```undefined```. This is because of the way, variables are hoisted during the creation of Variable Objects. Code is scanned for all the variables, and for each variable a property is created in Variable Object and set to ```undefined```.

* For example in ES5: 
```javascript
function driversLicense(passedTest){
	if(passedTest){
		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
		var firstName = 'John';
		var yearOfBirth = 1990;
	}
}
driversLicense(true);
```
OUTPUT: 
```undefined born in undefined is now officially allowed to drive car.```

* But in ES6:

```javascript
function driversLicense(passedTest){
	if(passedTest){
		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
		let firstName = 'John';
		const yearOfBirth = 1990;
	}
}
driversLicense(true);
```
OUTPUT: 
```Uncaught ReferenceError: Cannot access 'firstName' before initialization```

* IN ES6, This happens because of something called *Temporal-dead zone*, which basically just means that the variables are actually hoisted, but we still cannot access them before they are declared.
* So in ES6 we can only use a variable (if we use keyword ```const``` or ```let```) after we declare and define it.


### Blocks and IIFEs

* IIFEs (Immediately Invoked Function Expressions) help us in data privacy. They are immediately invoked and so their execution context gets popped off from the execution stack, immediately. This means the variables of these functions cannot be accessed as the scope chain is not accessible. But due to closure if the IIFE returns a function, that function can access the internal variables and functions and outside the IIFE we can acess the returned function.

* Since variables declared with keyword ```const``` and ```let``` are block scoped, it makes the syntax of IIFEs quite simple in ES6.

* Syntax for IIFEs in ES5 was:
```javascript
(function(){
	var a = 1;
	var b = 2;
})();

console.log(a + " "+ b);
```
OUTPUT
```javascript 
Uncaught ReferenceError: a is not defined
```
* With ES6, theres a new way to create IIFEs.

* Syntax for IIFEs in ES5 was:
```javascript
{
	const a = 1;
	let b = 2;
}

console.log(a + " "+ b);
```
OUTPUT
```javascript 
Uncaught ReferenceError: a is not defined
```

* Just to note, if we use ```var``` keyword for declaring variables inside the block we would still be able to access them outside because they are function-scoped.
```javascript
{
	const a = 1;
	let b = 2;
	var c = 3
}

console.log(c);
```
OUTPUT
```javascript 
3
```

### Strings
### Arrow Functions
### Destructuring
### Arrays
### Spread Operator
### Rest and Default Parameters
### Maps
### Classes and Subclasses
