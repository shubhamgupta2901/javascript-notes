## ES6
* [```let``` and ```const```](#let-and-const)
* [Blocks and IIFEs](#blocks-and-iifes)
* [Strings](#strings)
* [Arrow Functions](#arrow-functions)
* [Destructuring](#destructuring)
* [Arrays](#arrays)
* [Spread opreator](#spread-operator)
* [Rest Parameters](#rest-parameters)
* [Default Parameters](#default-parameters)
* [Maps](#maps)
* [Classes and Subclasses](#classes-and-subclasses)

##

### ```let``` and ```const```
* Instead of using ```var``` keyword, ES6 allows us to use ```let``` and ```const```.
* ```const``` is to be used for variables which will not change their values. There value can not be mutated.
* ```const``` variables need to be initiallized at the time of declaration. Otherwise we get ```Uncaught SyntaxError: Missing initializer in const declaration```

* ES5 Syntax:
```javascript
var nameES5 = 'Jane Smith';
var ageES5 = 23;
nameES5 = 'Jane Miller';
console.log(nameES5); //Jane Miller
```
* ES6 Syntax:
```javascript
const nameES6 = 'Jane Smith';
let ageES6 = 23;
ageES6 = 24;
console.log(ageES6); // 24
//nameES6 = 'Jane Miller'; // Uncaught TypeError: Assignment to constant variable.
```

* variables declared with ```var``` in ES5 are *function-scoped*, but variables declared with ```const``` and ```let``` in ES6 are *block-scoped*.
* A block groups zero or more statements.The block is delimited by a pair of curly brackets ```{}``` and may optionally be labelled.
* For example: 
ES5
```javascript
function driversLicense(passedTest){
	if(passedTest){
		var firstName = 'John';
		var yearOfBirth = 1990;

		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
	}
}
driversLicense(true);
```
OUTPUT: 
```John born in 1990 is now officially allowed to drive car.```

Also in ES5, 

```javascript
function driversLicense(passedTest){
	if(passedTest){
		var firstName = 'John';
		var yearOfBirth = 1990;
	}
	console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
}
driversLicense(true);
```
OUTPUT: 
```John born in 1990 is now officially allowed to drive car.```

* Lets look at same code in ES6 using ```const``` and ```let```:

```javascript
function driversLicense(passedTest){
	if(passedTest){
		let firstName = 'John';
		const yearOfBirth = 1990;
		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
	}
}
driversLicense(true);
```
OUTPUT: 
```John born in 1990 is now officially allowed to drive car.```


```javascript
function driversLicense(passedTest){
	if(passedTest){
		let firstName = 'John';
		const yearOfBirth = 1990;
	}
	console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
}
driversLicense(true);
```
OUTPUT: 
```Error: Uncaught ReferenceError: firstName is not defined```

* Another example for scoping is:
```javascript
let i = 23;
for (let i = 0; i< 5; i++){
	console.log(i);
}
console.log(i);
```
OUTPUT:
```
0
1
2
3
4
23
```

* This means assigning other values to ```i``` in the loop, doesn't change the value of ```i``` variable that we have defined before the for loop. Again this is because variables declared with ```let``` and ```const``` are block-scoped. And so the ```i``` variable inside the loop is a completeley different variable than the variable ```i``` that was defined before it.

* Where as in ES5: 

```javascript
var i = 23;
for (var i = 0; i< 5; i++){
	console.log(i);
}
console.log(i);
```
OUTPUT:
```
0
1
2
3
4
5
```

* Another difference between ES5 and ES6 is the way variables can be accessed before their declaration. 

* In ES5, when we use variables before they are declared, we get the value ```undefined```. This is because of the way, variables are hoisted during the creation of Variable Objects. Code is scanned for all the variables, and for each variable a property is created in Variable Object and set to ```undefined```.

* For example in ES5: 
```javascript
function driversLicense(passedTest){
	if(passedTest){
		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
		var firstName = 'John';
		var yearOfBirth = 1990;
	}
}
driversLicense(true);
```
OUTPUT: 
```undefined born in undefined is now officially allowed to drive car.```

* But in ES6:

```javascript
function driversLicense(passedTest){
	if(passedTest){
		console.log(firstName + " born in "+ yearOfBirth+ " is now officially allowed to drive car.");
		let firstName = 'John';
		const yearOfBirth = 1990;
	}
}
driversLicense(true);
```
OUTPUT: 
```Uncaught ReferenceError: Cannot access 'firstName' before initialization```

* IN ES6, This happens because of something called *Temporal-dead zone*, which basically just means that the variables are actually hoisted, but we still cannot access them before they are declared.
* So in ES6 we can only use a variable (if we use keyword ```const``` or ```let```) after we declare and define it.

##

### Blocks and IIFEs

* IIFEs (Immediately Invoked Function Expressions) help us in data privacy. They are immediately invoked and so their execution context gets popped off from the execution stack, immediately. This means the variables of these functions cannot be accessed as the scope chain is not accessible. But due to closure if the IIFE returns a function, that function can access the internal variables and functions and outside the IIFE we can acess the returned function.

* Since variables declared with keyword ```const``` and ```let``` are block scoped, it makes the syntax of IIFEs quite simple in ES6.

* Syntax for IIFEs in ES5 was:
```javascript
(function(){
	var a = 1;
	var b = 2;
})();

console.log(a + " "+ b);
```
OUTPUT
```javascript 
Uncaught ReferenceError: a is not defined
```
* With ES6, theres a new way to create IIFEs:

```javascript
{
	const a = 1;
	let b = 2;
}

console.log(a + " "+ b);
```
OUTPUT
```javascript 
Uncaught ReferenceError: a is not defined
```

* Just to note, if we use ```var``` keyword for declaring variables inside the block we would still be able to access them outside because they are function-scoped.
```javascript
{
	const a = 1;
	let b = 2;
	var c = 3
}

console.log(c);
```
OUTPUT
```javascript 
3
```
## 

### Strings
* There are big improvements on how we handle strings in ES6.

* Consider following lines of code
```javascript
let firstName = 'John';
let lastName = 'Smith';
const yearOfBirth = 1993;

function calcAge(year){
	return 2019-year;
}
```

* In ES5, if we wanted to put all the above data in a string, we needed to concatenate them with a ```+``` sign. Like this:

```javascript
console.log('This is '+ firstName + ' ' + lastName + ' and my age is '+ calcAge(yearOfBirth)+ ' years.');
```
OUTPUT:
```javascript
This is John Smith and my age is 26 years.
```

* In ES6 we have **Template Literal**. With this, we use backticks (`` ` ``) instead of quotation marks('' or ""). Rather than concatenating the variables using ```+``` sign, we use ```${}``` and put the variables inside them.

```javascript
console.log(`This is ${firstName} ${lastName} and my age is ${calcAge(yearOfBirth)} years.`);
```
OUTPUT:
```javascript
This is John Smith and my age is 26 years.
```

* Some new methods for strings:

```javascript
const n = `${firstName} ${lastName}`
console.log(n.startsWith('J'));  //case sensitive OUTPUT: true
console.log(n.includes(' '));  //case sensitive OUTPUT: true
console.log(n.endsWith('th'));  //case sensitive OUTPUT: true
console.log(firstName.repeat(5)); //JohnJohnJohnJohnJohn
console.log(`${firstName} `.repeat(5)); //John John John John John 
```
##

### Arrow Functions

* Suppose we have an array with birth years, and we want to calculate the age for each of these years:

```javascript
const years = [1990, 1965, 1982, 1937];
```
* In ES5 we can use the ```map()``` method like below,to loop over ```years``` array and return a new array with ages.

```javascript
var ages = years.map(function(year){
	return 2019-year;
});
console.log(ages);
```

OUTPUT:
```javascript
(4) [29, 54, 37, 82]
```

* In ES6 using **arrow functions**, we have a more quicker and concise way of writing methods like these, with callback functions.

```javascript
var ages = years.map((year)=> 2019-year);
console.log(ages);
```

OUTPUT:
```javascript
(4) [29, 54, 37, 82]
```

* There are three ways of writing arrow functions:
	* you put one argument and one line of code - which is the simplest form
	* If there are more than one arguments, use the parantheses ```()```
	* If we have more than one lines of code in function body, use curly braces and ```return``` keyword at the end.
	
* Remember in ```map()``` method, we have access to three different arguments: ```currentValue, currentIndex, array```. So if we need to use more than one parameters we can write this:

```javascript
var ages = years.map((year, index)=> `Age element at ${index} is ${2019-year}`);
console.log(ages);
```
OUTPUT:

```javascript
(4) ["Age element at 0 is 29", "Age element at 1 is 54", "Age element at 2 is 37", "Age element at 3 is 82"]
```

* If we have more than one line in the body of callback function, we can use the curly braces, and also the return keyword is not implicit and we have to write it again.

```javascript
var ages = years.map((element, index)=>{
	const currentYear = new Date().getFullYear();
	const age = currentYear - element;
	return `Age element at ${index}: ${age}`;

})
console.log(ages);
```

OUTPUT:
```javascript
(4) ["Age element at 0: 29", "Age element at 1: 54", "Age element at 2: 37", "Age element at 3: 82"]
```

* The biggest advantage of using arrow functions is unlike normal functions, arrow functions **don't** get their own ```this``` keyword. This means arrow functions do not have ```this``` keyword.They simply use the ```this``` keyword of the function they are written in. So we say they have *lexical* ```this``` keyword.

* Consider the following HTML file: 

```HTML
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ES6</title>
        <style>
            .box {
                width: 20px;
                padding: 6px;
                text-align: center;
                font-size: 3px;
                margin-top: 5px;
            }
            .green { background-color: green; }
            .blue { background-color: dodgerblue; }
            .orange { background-color: orangered; }
        </style>
    </head>
    <body>
        <h1></h1>
        <div class="box green">green!</div>
        <div class="box blue">blue!</div>
        <div class="box orange">orange!</div>
        <script src="arrow_functions_script.js"></script>
    </body>
</html>
```

* And in the ```arrow_functions_script.js``` file we have following code: 

```javascript
var box = {
	color: 'green',
	position: 1,
	clickMe: function(){
		console.log(this);
		document.querySelector('.green').addEventListener('click', function(){
			var str = 'This is box number '+ this.position + ' and it is '+ this.color + ' in color';
			console.log(str);
		});
	}
}
box.clickMe();
```
OUTPUT:
```javascript
{color: "green", position: 1, clickMe: ƒ}
This is box number undefined and it is undefined in color.
```

* In the method ```clickMe```, ```this``` keyword points to  the object ```box``` which is how it should be. Because in a method call, the ```this``` keyword points to the calling object.

* But the Reason for second line of output is: Only in method call the ```this``` keyword points to the object. But in a regular function,the this keyword will always point to the global object. But I think, the ```this``` keyword in any callback of an event handler points to  the element that triggered the event, in this case the div with class 'green'. (When I do ```console.log(this)``` from inside the body of callback function, I get output: ```<div class="box green">green!</div>```).

* Anyway ```this``` keyword from inside the body of callback function is not pointing to the object ```box```. That is why, when we write ```this.position``` and ```this.color``` returns ```undefined``` from inside the callback function.

* One solution to the current problem could be to do something like this:

```javascript
var box = {
	color: 'green',
	position: 1,
	clickMe: function(){
		var context = this;
		document.querySelector('.green').addEventListener('click', function(){
			var str = 'This is box number '+ context.position + ' and it is '+ context.color + ' in color';
			console.log(str);
		});
	}
}

box.clickMe();
```
OUTPUT
```javascript
This is box number 1 and it is green in color.
```

* Let's now replace the callback function with ES6 arrow function:

```javascript
var box = {
	color: 'green',
	position: 1,
	clickMe: function(){
		console.log(this);
		document.querySelector('.green').addEventListener('click', ()=>{
		console.log(this);
		});
	}
}

box.clickMe();
```

OUTPUT
```javascript
{color: "green", position: 1, clickMe: ƒ}
ONCLICKING: {color: "green", position: 1, clickMe: ƒ}
```

* This approach with arrow functions works, because the callback function is an arrow function and it does not have its own definition of ```this``` keyword and now shares the *lexical* ```this``` of the surrounding function, which is the ```box``` object.

* So we can write like this:

```javascript
let box = {
	color: 'green',
	position: 1,
	clickMe: function(){
		document.querySelector('.green').addEventListener('click', ()=>{
			let str = `This is box number ${this.position} and it is ${this.color} in color.`;
			console.log(str);
		});
	}
}
box.clickMe();
```

OUTPUT
```javascript
This is box number 1 and it is green in color.
```

* Note that there is still a function which we can still replace with arrow function.Something like this:

```javascript
let box = {
	color: 'green',
	position: 1,
	clickMe: () => {
		console.log(this);
		document.querySelector('.green').addEventListener('click', ()=>{
			let str = `This is box number ${this.position} and it is ${this.color} in color.`;
			console.log(str);
		});
	},
}
box.clickMe();
```

OUTPUT
```javascript
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
ONCLICK: This is box number undefined and it is undefined in color.
```

* The reason for such response is , when we used arrow function for ```clickMe``` it now shares the lexical ```this``` keyword from its surroundings, which is the global context.

* So I need to be very careful with these arrow functions, so that I don't lose track of what the ```this``` keyword actually points to.

* Lets now look at another example of arrow function with a function constructor. ES5 first:

```javascript
function Person(name){
	this.name = name;
}

Person.prototype.myFriends = function(friends){
	console.log(this);
	var arr = friends.map(function(el){
		console.log(this);
		return this.name + ' is friends with ' + el;
	});
	console.log(arr);
}

var friends = ['Bob', 'Jane', 'Mark'];
var john = new Person('John');
john.myFriends(friends);
```

OUTPUT

```javascript
Person {name: "John"}
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
(3) [" is friends with Bob", " is friends with Jane", " is friends with Mark"]
```

*  So in the ```myFriends``` method, Because it is a property, it's ```this``` points to the calling object, which in this case is ```Person``` object. But inside this method, we are calling another function, which is the anonymous function passed to ```map```. Since its a function, the ```this``` keyword here does not point to the calling object but the global context ```Window```.

* This is where ```bind``` , ```call``` and ```apply``` methods will come in handy. They will allow us to bind the ```this``` with functions that have different context.

```javascript
function Person(name){
	this.name = name;
}

Person.prototype.myFriends = function(friends){
	console.log(this);
	var arr = friends.map(function(el){
		console.log(this);
		return this.name + ' is friends with ' + el;
	}.bind(this));
	console.log(arr);
}

var friends = ['Bob', 'Jane', 'Mark'];
var john = new Person('John');
john.myFriends(friends);
```

OUTPUT
```javascript
Person {name: "John"}
Person {name: "John"}
Person {name: "John"}
Person {name: "John"}
(3) ["John is friends with Bob", "John is friends with Jane", "John is friends with Mark"]
```
* ES6 equivalent:
```javascript
function Person(name){
	this.name = name;
}

Person.prototype.myFriends = function(friends){
	console.log(this);
	var arr = friends.map(el =>{
		console.log(this);
		return this.name + ' is friends with ' + el;
	});
	console.log(arr);
}

var friends = ['Bob', 'Jane', 'Mark'];
var john = new Person('John');
john.myFriends(friends);
```

OUTPUT
```javascript
Person {name: "John"}
Person {name: "John"}
Person {name: "John"}
Person {name: "John"}
(3) ["John is friends with Bob", "John is friends with Jane", "John is friends with Mark"]
```

* To make it look more concise:

```javascript
function Person(name){
	this.name = name;
}
Person.prototype.myFriends = function(friends){
	console.log(this);
	var arr = friends.map(el => `${this.name} is friends with ${el}`);
	console.log(arr);
}

var friends = ['Bob', 'Jane', 'Mark'];
var john = new Person('John');
john.myFriends(friends);
```

OUTPUT:
```
Person {name: "John"}
(3) ["John is friends with Bob", "John is friends with Jane", "John is friends with Mark"]
```
##

### Destructuring

* Destructuring is a very convenient way to extract data from a data structure like an object or an array.
* Consider a following array:

```javascript
var john = ['John', 26];
```
*  Suppose we wanted to store each of the element in a seperate variable, we would simply have to write one variable for each element like this:

```javascript
var name =john[0];
var age = john[1];
```
* If we had many more elements in that array, extracting them and storing them in a seperate variable would become impractical. So in ES6 we have something called **Destructuring** for such problems:

```javascript
const [name, year] = ['john', 26];
```

* What this is going to do is it is going to create a ```const``` called ```name``` and ```const``` called ```year``` and then the data will be stored in each of these variables.

```javascript
console.log(name);
console.log(year);
```
OUTPUT:
```javascript
john
26
```
* This works well with objects too, all we need to ensure is that the keys match is exactly same way:

```javascript
const obj = {
	firstName: 'John',
	lastName: 'Smith',
}

const {lastName, firstName} = obj;
console.log(`${firstName} ${lastName}`);

```
OUTPUT:
```javascript
John Smith
```
* If we don't want the variable names to match with the key names , then we can use different names:

```javascript
const obj = {
	firstName: 'John',
	lastName: 'Smith',
}

const{ firstName: a, lastName: b} = obj;
console.log(`${a} ${b}`);

```

OUTPUT:
```javascript
John Smith
```

* Lets look at a more practical way of destructuring.

```javascript
function calcAgeRetirement(year){
	const age = new Date().getFullYear()-year;
	return [age, 65-age];
}

const [age, retirement] = calcAgeRetirement(1990);
console.log(age);
console.log(retirement);

```

//OUTPUT:
```javascript
29
36
```
* For objects: 
```javascript
function calcAgeRetirement(year){
	const age = new Date().getFullYear() - year;
	return {
		age: age,
		ageUntilRetirement: 65-age,
	};
}

const {ageUntilRetirement} = calcAgeRetirement(1990);
console.log(ageUntilRetirement);
```

OUTPUT:
```javascript
36
```
## 

### Arrays
* Consider the HTML file again:
```HTML
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ES6</title>
        <style>
            .box {
                width: 200px;
                padding: 60px;
                text-align: center;
                font-size: 20px;
                margin-top: 50px;
            }
            .green { background-color: green; }
            .blue { background-color: dodgerblue; }
            .orange { background-color: orangered; }
        </style>
    </head>
    <body>
        <h1></h1>
        <div class="box green">green!</div>
        <div class="box blue">blue!</div>
        <div class="box orange">orange!</div>
        <script src="arrays_script.js"></script>
    </body>
</html>
```
* In our script, lets select all the boxes:

```javascript
const boxes = document.querySelectorAll('.box');
```

* ```boxes``` is a ```NodeList``` and not an array. In ES6 we can convert it to an array using **```Array.from()```**, and then we can change the color of all boxes to blue:

```javascript
const boxesArray =  Array.from(boxes);
boxesArray.forEach(cur => cur.style.backgroundColor = 'dodgerblue');
```

* Usually when we we want to loop through the entire array we could use either ```forEach``` or ```map``` methods. But these methods do not allow use of ```break``` and ```continue``` statements.

* So suppose for all the boxes with classes which are not ```blue``` we want to change their text, and we want to use a ```continue``` statement.

* ```continue``` will simply skip the current iteration of the loop and go right to the next one, and ```break``` keyword will break the loop and it would stop here and not continue to the next iteration.

* So in cases like these, where we want to use ```break``` or ```continue``` method on loop, we can not use ```forEach``` and ```map```. Then we would have to write something like this in ES5:

```javascript
for(var i = 0; i<boxesArray.length; i++){
	if(boxesArray[i].className === 'box blue'){
		continue;
	}
	boxesArray[i].textContent = 'I changed to blue';
}
```

* This forces us to use a lot of code for a very simple loop. Now in ES6 we now have a new loop **```for...of```** which combines the benefits of ```for``` and ```forEach``` loops. It allows us to use keywords ```break``` and ```continue```.

SYNTAX:
```javascript
for (variable of iterable) {
  statement
}
```

USAGE: 
```javascript
for(let cur of boxesArray){
	if(cur.className === 'box blue')
		continue;
	cur.textContent = 'I changed to BLUE';
}
```

##

### Spread Operator

* Spread operator is a very convenient way to expand elements of an array in places like arguments and function calls.

* Consider a function that four arguments and returns their sum:
```javascript
function addFourAges(a,b,c,d){
	return a+b+c+d;
}

var sum = addFourAges(18,30,12,21);
console.log(sum);
```
OUTPUT:
```
81
```

* Now if we had these four arguments in an array instead of four different variables, how could we pass the entire array to the function? We would do something like this in ES5:

```javascript
var numbers = [18,30,12,21];
var sum = addFourAges(numbers[0],numbers[1],numbers[2],numbers[3]);
console.log(sum);
```
OUTPUT:
```
81
```

* We could also use the ```apply``` method, which recieves an array as an argument, and it calls the function that the ```apply``` method is used on by using the elements of the array as the arguments. Remember the first argument it takes is the ```this``` variable -  the execution context for the method. Since there is no context related work here, we can pass ```null```.

* So we can do something like this:

```javascript
var numbers = [18,30,12,21];
var sum = addFourAges.apply(null, numbers);
console.log(sum);
```
OUTPUT:
```
81
```

* However using **spread operator (```...```)** there's a better way to do this in ES6:

```javascript
let numbers = [18,30,12,21];
let sum = addFourAges(...numbers);
console.log(sum);
```
OUTPUT:
```
81
```
* What this operator does is it expands this array ```numbers``` into its components.

* Another use case is when we need to join two arrays:

```javascript
const familySmith = ['John', 'Jane', 'Mark'];
const familyMiller = ['Mary', 'Bob', 'Ann'];
const bigFamily =[...familySmith, ...familyMiller];
console.log(bigFamily);
```
OUTPUT:
```
(6) ["John", "Jane", "Mark", "Mary", "Bob", "Ann"]
```
* What the above code is doing is it is expanding the arrays into single elements. So it basically takes all array elements out and puts them in array ```bigFamily```. And obviously, we can put our own elements in there as well:

```javascript
const bigFamily = [...familySmith, 'Brutus',...familyMiller];
```

OUTPUT:
```
(7) ["John", "Jane", "Mark", "Brutus", "Mary", "Bob", "Ann"]
```

*  We can also use this spread operator on other structures like ```NodeList``` (it is returned by ```querySelectorAll()``` method):

HTML:
```HTML
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ES6</title>
        <style>
            .box {
                width: 200px;
                padding: 60px;
                text-align: center;
                font-size: 20px;
                margin-top: 50px;
            }
            .green { background-color: green; }
            .blue { background-color: dodgerblue; }
            .orange { background-color: orangered; }
        </style>
    </head>
    <body>
        <h1>ES6</h1>
        <div class="box green">green!</div>
        <div class="box blue">blue!</div>
        <div class="box orange">orange!</div>
        <script src="spread_operator_script.js"></script>
    </body>
</html>
```
JAVASCRIPT: 
```javascript
const h = document.querySelector('h1'); // node
const boxes = document.querySelectorAll('.box'); //NodeList
const all = [h, ...boxes]; //NodeList
for(element of all){
	element.style.color = 'purple';
}
console.log(all);
```

OUTPUT:
``` javascript
(4) [h1, div.box.green, div.box.blue, div.box.orange]
```

##

### Rest Parameters
* Rest parameters allow us to pass an arbitary number of arguments into a function and use these arguments in that function.

* Rest parameters look exactly like spread operator (```...```) but they are very different.

* Spread operator takes an array, and basically transforms them it into single values, while the rest parameter, receives arbitary number of single values and transforms them into an array when we call a function with multiple parameters.

* Suppose we want to create a function that receives an arbitary number of years and then prints to the console whether each person corresponding to the these years is of full age or not.

* In ES5 if we want to receive an undefined number of arguments, then we simply don't define any parameters for our function and then we simply use the ```arguments``` keyword. ```arguments``` variable is very similar to ```this``` variable, and its a variable that each execution context gets access to, so it can be accessed from all functions.

* Lets first log this variable to see how it looks like:

```javascript
function isFullAge(){
	console.log(arguments);
}
isFullAge();
```
OUTPUT:
```javascript
Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]
callee: ƒ isFullAge()
length: 0
Symbol(Symbol.iterator): ƒ values()
__proto__: Object
```

* If I call the same function with some arguments, lets see what we get when we console.log ```arguments``` variable:
```javascript
function isFullAge(){
	console.log(arguments);
}
isFullAge(1990, 1999, 1965);
```
OUTPUT:
```javascript
Arguments(3) [1990, 1999, 1965, callee: ƒ, Symbol(Symbol.iterator): ƒ]
0: 1990
1: 1999
2: 1965
callee: ƒ isFullAge()
length: 3
Symbol(Symbol.iterator): ƒ values()
__proto__: Object
```
* So we can see that the ```arguments``` variable looks like an array, but in fact it is not an array. (Its ```__proto___``` is ```Object```. But arrays are created by using ```Array``` function constructor so their ```__proto__``` is ```Array```).

* So it is array-like but not an array. (Go figure that out). So if we want to access the parameters passed we can always convert them back to an array using ```Array.from()``` method. But surprisingly following syntax works without converting ```arguments``` into an array:

```javascript
function isFullAge(){
	console.log(arguments[0]);
	console.log(arguments[1]);
	console.log(arguments[2]);
	console.log(arguments[3]);
}
isFullAge(1990, 1999, 1965);
```
OUTPUT:
```javascript
1990
1999
1965
undefined
```
* So our implementation of the problem could be like this in ES5:

```javascript
function isFullAge(){
	for(let i=0; i<arguments.length; i++){
		console.log(2019-arguments[i] >= 18);
	}
}
isFullAge(1990, 1999, 1965,2003);
```
OUTPUT:
```javascript
true
true
true
false
```
* We could pass any number of arguments in the function ```isFullAge``` and it will work.

* Lets now have a look at **Rest Parameters** in ES6.Here, rather than not having any arguments like ES5, we use the rest parameters operator (which looks same as spread operator). And then we write the name of the variable. Now as soon as we call the function ```isFullAge```, this rest parameter will transform the arbitary number of arguments passed to ```isFullAge``` into an array and will pass it to the ```isFullAge```.

```javascript
function isFullAge(...years){
	console.log(years);
}
isFullAge(1990, 1999, 1965,2003);
```

OUTPUT:
```javascript
(4) [1990, 1999, 1965, 2003]
0: 1990
1: 1999
2: 1965
3: 2003
length: 4
__proto__: Array(0)
```

* Note that ```years``` is actually an array. Because its ```__proto__``` is ```Array```.

* And now our solution in ES6 could be:

```javascript
function isFullAge(...years){
	for(year of years){
		console.log(2019-year >=18);
	}
}
isFullAge(1990, 1999, 1965,2003);
```
OUTPUT:
```javascript
true
true
true
false
```

* The big difference between the spread operator and rest parameter is the place at which we use them. ** Spread operator is used in the function call, while the rest parameter is used in function declaration to accept an arbitary number of parameters**.

* Adding addtional parameters along with rest parameters is very easy. Consider in the above examples we would like to pass an argument ```limit```, which is the age at which a person becomes full age rather than 18. Then we could do something like this:

```javascript
function isFullAge(limit,...years){
	console.log(limit);
	console.log(years);
}

isFullAge(21, 1990, 1999, 1965, 2003);
```

OUTPUT:
```javascript
21
(4) [1990, 1999, 1965, 2003]
```
* So our implementation of function could be like this:

```javascript
function isFullAge(limit, ...years){
	for(year of years){
		console.log(2019-year >=limit);
	}
}

isFullAge(21, 1990, 1999, 1965, 2003);
```
OUTPUT:
```javascript
true
false
true
false
```

##

### Default Parameters

* We use the default parameters when we want one or more parameters of the functions to have a default value, in cases when we don't pass it as argument.

* Theres also a way to do this in ES5:

```javascript
function SmithPerson(firstName, yearOfBirth, lastName, nationality){
	this.firstName = firstName;
	this.yearOfBirth = yearOfBirth;
	this.lastName = lastName;
	this.nationality = nationality;
}

var john = new SmithPerson("John", 1990);
console.log(john);
```
OUTPUT:
```javascript
SmithPerson {firstName: "John", yearOfBirth: 1990, lastName: undefined, nationality: undefined}
```

* Remember JS actually allows us to call a function without specifying all the arguments. In this case we only specify ```firstName``` and ```yearOfBirth```, but leave the ```lastName``` and ```nationality```. What JS does is it simply assigns ```undefined``` to the ```lastName``` and ```nationality``` parameters.

* If we want to pass default value of ```lastName``` and ```nationality```, we could de something like this:
```javascript
function SmithPerson(firstName, yearOfBirth, lastName, nationality){
	this.firstName = firstName;
	this.yearOfBirth = yearOfBirth;
	this.lastName = lastName === undefined ? 'Smith': lastName;
	this.nationality = nationality === undefined ? 'Swiss': nationality;
}
var john = new SmithPerson("John", 1990);
var emily = new SmithPerson("Emily", 1993, 'Diaz','British');
console.log(john);
console.log(emily);
```

OUTPUT:
```javascript
SmithPerson {firstName: "John", yearOfBirth: 1990, lastName: "Smith", nationality: "Swiss"}
SmithPerson {firstName: "Emily", yearOfBirth: 1993, lastName: "Diaz", nationality: "British"}
```
* In ES6 it is very simple:

```javascript
function SmithPerson(firstName, yearOfBirth, lastName = 'Smith', nationality = 'Swiss'){
	this.firstName = firstName;
	this.yearOfBirth = yearOfBirth;
	this.lastName = lastName;
	this.nationality = nationality;
}

let john = new SmithPerson('John',1990);
let emily = new SmithPerson('Emily', 1993, 'Diaz', 'British');
let jason = new SmithPerson('Jason', 1983, undefined, 'American');
let alex = new SmithPerson('Alex', 1983, null, 'Indian');

console.log(john);
console.log(emily);
console.log(jason);
console.log(jason);
```
OUTPUT:
```javascript
SmithPerson {firstName: "John", yearOfBirth: 1990, lastName: "Smith", nationality: "Swiss"}
SmithPerson {firstName: "Emily", yearOfBirth: 1993, lastName: "Diaz", nationality: "British"}
SmithPerson {firstName: "Jason", yearOfBirth: 1983, lastName: "Smith", nationality: "American"}
SmithPerson {firstName: "Jason", yearOfBirth: 1983, lastName: "Smith", nationality: "American"}
```
##

### Maps

* A very common use of javascript objects is to use them as Hashmaps, which is a key-value datastructure.

* In ES6, we now have a new datastructure ```Maps``` for using them as Hashmaps. The one major difference between ```Maps``` and objects is: In objects, the keys could only be a string. But in ```Maps``` we can use any thing for keys( primitive values like numbers, boolean, string and even functions, objects).

```javascript
//Create a map
const map = new Map();

// Setting key as string
map.set('question', 'What\'s your name?');
//Setting key as number
map.set(1, 'Jane');
map.set(2, 'Jack');
map.set(3, 'Emily');
//Setting key as string
map.set('correct', 2);
//setting key as boolean
map.set(true, 'Correct Answer');
map.set(false,'Wrong Answer');

//retreiving values
console.log(map.get('question')); //What's your name?

//getting size
console.log(map.size); //7

//deleting data
map.delete(3);

//checking if a key is present
console.log(map.has('correct')); //true

//deleting all key-value pairs from map
//map.clear();
```
* Unlike objects, **maps are iterable**. That means we can loop through a map.The ```entries()``` method returns a new ```Iterator``` object that contains the ```[key, value]``` pairs for each element in the Map object in insertion order.

* using for each loop

```javascript
map.forEach((value,key)=>{
	console.log(`key: ${key} | value: ${value}`);
});
```

OUTPUT
```javascript
key: question | value: What's your name?
key: 1 | value: Jane
key: 2 | value: Jack
key: correct | value: 2
key: true | value: Correct Answer
key: false | value: Wrong Answer
```

* using for of loop

```javascript
for(let pair of map.entries()){
	console.log(`pair: ${pair} `);
}
```

OUTPUT
```javascript
pair: question,What's your name?
pair: 1,Jane
pair: 2,Jack
pair: correct,2
pair: true,Correct Answer
pair: false,Wrong Answer
```

* Use destructuring to extract key and value
```javascript
for(let [key,value] of map.entries()){
	console.log(`key: ${key} | value: ${value}`);
}
```
OUTPUT
```javascript
key: question | value: What's your name?
key: 1 | value: Jane
key: 2 | value: Jack
key: correct | value: 2
key: true | value: Correct Answer
key: false | value: Wrong Answer
```

### Classes and Subclasses

* Classes actually don't add anything new to the language. They are just synthetic sugar over the way we do prototypal inheritance in javascript.This means classes simply make it easier to implement inheritance and to create objects based on blueprints.

* **Class definitons are not hoisted**. So unlike function constructors, we need to first implement the a class, and only later in the code we can start using it.

* We can only add methods to classes but not properties. Inheriting properties through the objects is not a good practice anyway, so that rule is now enforced.

* In ES5, we created objects using function constructors. And then we can add methods or properties to the prototype property of these objects. This means all the instances created through this function constructor will inherit these methods.

```javascript
function Person (name, yearOfBirth, job){
	this.name = name;
	this.yearOfBirth = yearOfBirth;
	this.job = job;
}

Person.prototype.calculateAge = function(){
	return new Date().getFullYear() - this.yearOfBirth;
}

var jane = new Person("Jane", 1993, 'SDE');
console.log(jane);
jane.calculateAge();
```

OUTPUT:
```javascript
Person {name: "Jane", yearOfBirth: 1993, job: "SDE"}job: "SDE"name: "Jane"yearOfBirth: 1993__proto__: Object
26
```
* With ES6

```javascript
class Person{
	constructor(name, yearOfBirth, job){
		this.name = name;
		this.yearOfBirth = yearOfBirth;
		this.job = job;
	}

	calculateAge(){
		return new Date().getFullYear() - this.yearOfBirth;
	}
}

var jane = new Person("Jane", 1993, 'SDE');
console.log(jane);
console.log(jane.calculateAge());
```

OUTPUT:
```javascript
Person {name: "Jane", yearOfBirth: 1993, job: "SDE"}
26
```

* We can also have **static methods** inside the class. These methods belong to the class and not to instances of the class.

```javascript
class Person{
	constructor(name, yearOfBirth, job){
		this.name = name;
		this.yearOfBirth = yearOfBirth;
		this.job = job;
	}

	calculateAge(){
		return new Date().getFullYear() - this.yearOfBirth;
	}

	static greeting(){
		console.log("Hey There");
	}
}

Person.greeting(); //Hey There
var jane = new Person("Jane", 1993, 'SDE');
jane.greeting(); //Uncaught TypeError: jane.greeting is not a function

```

OUTPUT:
```javascript
Hey There
Uncaught TypeError: jane.greeting is not a function
```

#### Inheritance

* Inheritance in ES5 could be implemented like this:

```javascript
function Person (name, yearOfBirth, job){
	this.name = name;
	this.yearOfBirth = yearOfBirth;
	this.job = job;
}

Person.prototype.calculateAge = function(){
	return new Date().getFullYear() - this.yearOfBirth;
}

function Athlete( name, yearOfBirth, job, olympicGames, medals){
		Person.call(this, name, yearOfBirth, job);
		this.olympicGames = olympicGames;
		this.medals = medals;
}

Athlete.prototype = Object.create(Person.prototype);

var johnAthlete = new Athlete('John', 1990, 'swimmer', 3, 10);
console.log(johnAthlete);
console.log(johnAthlete.calculateAge());
```

OUTPUT
```javascript
Athlete {name: "John", yearOfBirth: 1990, job: "swimmer", olympicGames: 3, medals: 10}
job: "swimmer"
medals: 10
name: "John"
olympicGames: 3
yearOfBirth: 1990
__proto__: Person

29
```

* In ```Athlete``` we are calling the super class function constructor using ```call``` method with ```this```. To understand this we need to remember how the ```new``` operator works, which is the operator which we use to create new instances. So when creating a new ```Athlete``` object, ```new``` creates a new empty object, calls the ```Athlete``` function constructor and sets the ```this``` keyword to the newly created empty ```Athlete``` objects.

* Now when we call ```Person``` function constructor in the very first line, with ```this``` keyword as first argument, all the properties ```name```, ```yearOfBirth``` and ```job``` will be set in the new ```Athlete``` object.

* To create the correct prototype chain, we need to use ```Object.create()```, because it allows us to manually set the prototype of an object and we want the prototype of ```Athlete``` to be the prototype of ```Person```.

* Adding another method to ```Athlete``` prototype:

```javascript
Athlete.prototype.wonMedal = function(){
	this.medals++;
	console.log(this.medals);
}

johnAthlete.wonMedal();
```
OUTPUT
```javascript
11
```
* With ES6 inheritance is easy:

```javascript
class Person{
	constructor(name, yearOfBirth, job){
		this.name = name;
		this.yearOfBirth = yearOfBirth;
		this.job = job;
	}

	calculateAge(){
		const age = new Date().getFullYear() - this.yearOfBirth;
		console.log(age);
	}
}

class Athlete extends Person{
	constructor(name, yearOfBirth, job,olympicGames, medals){
		super(name, yearOfBirth, job);
		this.olympicGames = olympicGames;
		this.medals = medals;
	}

	wonMedal(){
		this.medals++;
		console.log(this.medals);
	}
}


let johnAthlete = new Athlete('John',1990, 'swimmer', 3, 10);
johnAthlete.wonMedal();
johnAthlete.calculateAge();
```

OUTPUT
```javascript
11
29
```

##
